using BookLibrary.Server.Application.Exceptions;
using BookLibrary.Server.Application.Interface;
using BookLibrary.Server.Domain.Entities;
using CloudinaryDotNet;
using CloudinaryDotNet.Actions;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using System.Net;

namespace BookLibrary.Server.Infrastructure.Services
{
    public class FileUploadService(Cloudinary cloudinary, IConfiguration configuration, IServiceProvider serviceProvider) : IFileUploadService
    {
        public async Task<string> UploadFileAsync(IFormFile file, string folder)
        {
            await using var stream = file.OpenReadStream();
            var uploadParams = new ImageUploadParams
            {
                Folder = folder,
                File = new FileDescription(file.FileName, stream)
            };
            var uploadResult = await cloudinary.UploadAsync(uploadParams);

            if (uploadResult.StatusCode != HttpStatusCode.OK)
                throw new Exception("Cloudinary upload failed");

            Console.WriteLine("File uploaded to Cloudinary: " + uploadResult.SecureUrl.ToString());
            return uploadResult.SecureUrl.ToString();
        }

        public async Task<string> GetSignedUrlAsync(string url)
        {
            try
            {
                // Create a new Cloudinary instance
                var cloudinary = new Cloudinary(
                    new Account(
                        configuration["Cloudinary:CloudName"],
                        configuration["Cloudinary:ApiKey"],
                        configuration["Cloudinary:ApiSecret"]
                    )
                );

                // Extract the public ID from the URL
                string publicId = ExtractPublicIdFromUrl(url);

                // Determine resource type based on file extension
                ResourceType resourceType = ResourceType.Image; // Default
                if (publicId.EndsWith(".pdf", StringComparison.OrdinalIgnoreCase))
                {
                    resourceType = ResourceType.Raw;
                }
                else if (publicId.EndsWith(".mp4", StringComparison.OrdinalIgnoreCase) ||
                         publicId.EndsWith(".mov", StringComparison.OrdinalIgnoreCase))
                {
                    resourceType = ResourceType.Video;
                }

                // Set expiration time to 1 hour from now
                var expirationTime = (int)(DateTime.UtcNow.AddHours(1) - new DateTime(1970, 1, 1)).TotalSeconds;

                // Create parameters for signing
                var parameters = new Dictionary<string, object>
                {
                    { "public_id", publicId },
                    { "timestamp", expirationTime }
                };

                // Generate signature
                var signature = cloudinary.Api.SignParameters(parameters);

                // Construct the URL manually
                var cloudName = configuration["Cloudinary:CloudName"];
                var resourceTypeStr = resourceType.ToString().ToLower();

                return $"https://res.cloudinary.com/{cloudName}/{resourceTypeStr}/upload/s--{signature}--/t_{expirationTime}/{publicId}";
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error generating signed URL: {ex.Message}");
                // Return the original URL as a fallback
                return url;
            }
        }

        public async Task<string> GetFileUrlAsync(Guid id, string type)
        {
            // This method would typically query your database to get the file URL
            // For this example, we'll use a simplified approach

            // Get the book to find the file URL
            var bookRepository = serviceProvider.GetRequiredService<IGenericRepository<Book>>();
            var book = await bookRepository.GetByIdAsync(id);

            if (book == null || book.Result == null)
                throw new NotFoundException("Book not found", typeof(Book));

            // Return the appropriate URL based on the type
            if (type.ToLower() == "pdf")
                return book.Result.PdfUrl ?? throw new NotFoundException("PDF not found", typeof(string));
            else
                return book.Result.ImageUrl ?? throw new NotFoundException("Image not found", typeof(string));
        }

        private string ExtractPublicIdFromUrl(string url)
        {
            try
            {
                var uri = new Uri(url);
                var pathSegments = uri.AbsolutePath.TrimStart('/').Split('/');

                // Find the index of "upload" in the path segments
                int uploadIndex = Array.IndexOf(pathSegments, "upload");
                if (uploadIndex < 0 || uploadIndex + 2 >= pathSegments.Length)
                {
                    throw new ArgumentException("Invalid Cloudinary URL format");
                }

                // Skip the version part (v1745671470) and get the rest as the public ID
                var publicIdParts = pathSegments.Skip(uploadIndex + 2);
                return string.Join("/", publicIdParts);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error extracting public ID: {ex.Message}");
                throw;
            }
        }

        public async Task<byte[]> FetchCloudinaryFileAsync(string url)
        {
            if (string.IsNullOrEmpty(url))
                throw new ArgumentNullException(nameof(url), "URL cannot be null or empty");

            // Extract the public ID from the Cloudinary URL
            var parts = url.Split('/');
            var uploadIndex = Array.IndexOf(parts, "upload");
            if (uploadIndex < 0 || uploadIndex + 2 >= parts.Length)
            {
                throw new ArgumentException("Invalid Cloudinary URL format");
            }

            // Skip the version part (v1745671470) and get the rest as the public ID
            var publicIdParts = parts.Skip(uploadIndex + 2).ToArray();
            var publicId = string.Join("/", publicIdParts);

            // Determine resource type based on file extension
            string resourceType = "image"; // Default
            if (publicId.EndsWith(".pdf"))
            {
                resourceType = "raw";
            }
            else if (publicId.EndsWith(".mp4") || publicId.EndsWith(".mov"))
            {
                resourceType = "video";
            }

            // Generate a signed URL with an expiration time
            var timestamp = (int)DateTimeOffset.UtcNow.AddHours(1).ToUnixTimeSeconds();
            var signature = GenerateSignature(publicId, timestamp);

            // Construct the signed URL
            var cloudName = configuration["Cloudinary:CloudName"];
            var apiKey = configuration["Cloudinary:ApiKey"];
            var signedUrl = $"https://res.cloudinary.com/{cloudName}/{resourceType}/upload/s--{signature}--/t_{timestamp}/{publicId}";

            // Fetch the file using the signed URL
            using var httpClient = new HttpClient();
            var response = await httpClient.GetAsync(signedUrl);

            if (!response.IsSuccessStatusCode)
                throw new HttpRequestException($"Failed to fetch file from Cloudinary: {response.StatusCode}");

            return await response.Content.ReadAsByteArrayAsync();
        }

        private string GenerateSignature(string publicId, int timestamp)
        {
            var apiSecret = configuration["Cloudinary:ApiSecret"];
            var stringToSign = $"public_id={publicId}×tamp={timestamp}{apiSecret}";

            using (var sha1 = System.Security.Cryptography.SHA1.Create())
            {
                var hash = sha1.ComputeHash(System.Text.Encoding.UTF8.GetBytes(stringToSign));
                return BitConverter.ToString(hash).Replace("-", "").ToLower();
            }
        }
    }
}
